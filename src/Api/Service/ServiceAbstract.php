<?php
/**
 * B2W Digital - Companhia Digital
 *
 * Do not edit this file if you want to update this SDK for future new versions.
 * For support please contact the e-mail bellow:
 *
 * sdk@e-smart.com.br
 *
 * @category  BSeller
 * @package   BSeller
 *
 * @copyright Copyright (c) 2018 B2W Digital - BIT Tools Platform. .
 *
 * @author    Julio Reis <julio.reis@b2wdigital.com>
 */

namespace BSeller\Api\Service;

use GuzzleHttp\Client as HttpClient;
use BSeller\Api;
use BSeller\Api\Helpers;
use BSeller\Api\Handler\Response\HandlerDefault;
use BSeller\Api\Log\Loggerable;
use BSeller\Api\Log\TypeInterface\Request;
use BSeller\Api\Log\TypeInterface\Response;
use BSeller\Api\Handler\Response\HandlerException;

abstract class ServiceAbstract implements ServiceInterface
{
    
    use Loggerable, Helpers;
    
    
    const REQUEST_METHOD_GET    = 'GET';
    const REQUEST_METHOD_POST   = 'POST';
    const REQUEST_METHOD_PUT    = 'PUT';
    const REQUEST_METHOD_HEAD   = 'HEAD';
    const REQUEST_METHOD_DELETE = 'DELETE';
    const REQUEST_METHOD_PATCH  = 'PATCH';

    
    /** @var HttpClient */
    protected $client = null;
    
    /** @var array */
    protected $headers = [];
    
    /** @var int */
    protected $timeout = 15;
    
    /** @var int */
    protected $requestId = null;
    
    
    /**
     * Service constructor.
     *
     * @param string $baseUri
     * @param array  $headers
     * @param array  $options
     */
    public function __construct($baseUri = null, array $headers = [], array $options = [], $log = true)
    {
        $this->headers = array_merge($this->headers, $headers);
        
        $defaults = [
            'headers' => $headers,
        ];

        if (empty($baseUri)) {
            /*
             * @todo change this URL to production enviroment after development phase;
             */
            $baseUri = 'http://backstg.bseller.com.br/api';
        }
    
        foreach ($options as $key => $value) {
            $defaults[$key] = $value;
        }
        
        $this->prepareHttpClient($baseUri, $defaults);
    
        return $this;
    }
    
    
    /**
     * @param bool $renew
     *
     * @return int
     */
    public function getRequestId($renew = false)
    {
        if (empty($this->requestId) || $renew) {
            $this->requestId = rand(1000000000, 9999999999);
        }
        
        return $this->requestId;
    }
    
    
    /**
     * @param string $method
     * @param string $uri
     * @param null   $body
     * @param array  $options
     *
     * @return Api\Handler\Response\HandlerInterfaceException|Api\Handler\Response\HandlerInterfaceSuccess
     */
    public function request($method, $uri, $body = null, $options = [], $debug = false)
    {
        $options['timeout'] = $this->getTimeout();
        $options['headers'] = $this->headers;
        $options['debug']   = (bool) $debug;
        
        $options = $this->prepareRequestBody($body, $options);
        
        /** Log the request before sending it. */
        $logRequest = new Request(
            $this->getRequestId(),
            $method,
            $uri,
            $body,
            $this->protectedHeaders($this->headers),
            $this->protectedOptions($options)
        );
        
        $this->logger()->logRequest($logRequest);

        try {
            /** @var \GuzzleHttp\Message\Request $request */
            $request = $this->httpClient()->createRequest($method, $uri, $options);

            /** @var \GuzzleHttp\Message\Response $response */
            $response = $this->httpClient()->send($request);
    
            /** @var Api\Handler\Response\HandlerInterfaceSuccess $responseHandler */
            $responseHandler = new HandlerDefault($response);
    
            /** Log the request response. */
            $logResponse = (new Response($this->getRequestId()))->importResponseHandler($responseHandler);
        } catch (\Exception $e) {
            /** @var Api\Handler\Response\HandlerInterfaceException $responseHandler */
            $responseHandler = new HandlerException($e);
            
            /** Log the request response. */
            $logResponse = (new Response($this->getRequestId()))->importResponseExceptionHandler($responseHandler);
        }
        
        $this->logger()->logResponse($logResponse);
        
        return $responseHandler;
    }
    
    
    /**
     * @param string|array $bodyData
     * @param array        $options
     *
     * @return array
     */
    protected function prepareRequestBody($bodyData, array &$options = [])
    {
        $options['body'] = $bodyData;
        return $options;
    }
    
    
    /**
     * A private __clone method prevents this class to be cloned by any other class.
     *
     * @return void
     */
    private function __clone()
    {
    }
    
    
    /**
     * A private __wakeup method prevents this object to be unserialized.
     *
     * @return void
     */
    private function __wakeup()
    {
    }
    
    
    /**
     * @return HttpClient
     */
    protected function httpClient()
    {
        return $this->client;
    }
    
    
    /**
     * @param null  $baseUri
     * @param array $defaults
     *
     * @return HttpClient
     */
    protected function prepareHttpClient($baseUri = null, array $defaults = [])
    {
        if (null === $this->client) {
            $this->client = new HttpClient([
                'base_uri' => $baseUri,
                'base_url' => $baseUri,
                'defaults' => $defaults
            ]);
        }
    
        return $this->client;
    }
    
    
    /**
     * @return array
     */
    public function getHeaders()
    {
        return (array) $this->headers;
    }
    
    
    /**
     * @param array $headers
     * @param bool  $append
     *
     * @return $this
     */
    public function setHeaders(array $headers = [], $append = true)
    {
        if (!$append) {
            $this->headers = $headers;
            return $this;
        }
        
        foreach ($headers as $key => $value) {
            $this->headers[$key] = $value;
        }
        
        return $this;
    }
    
    
    /**
     * @return int
     */
    public function getTimeout()
    {
        return (int) $this->timeout;
    }
    
    
    /**
     * @param integer $timeout
     *
     * @return $this
     */
    public function setTimeout($timeout)
    {
        $this->timeout = (int) $timeout;
        return $this;
    }
    
    
    /**
     * @param $options
     *
     * @return mixed
     */
    protected function protectedOptions($options)
    {
        $headers = $this->arrayExtract($options, 'headers');
        
        if (empty($headers)) {
            return $options;
        }
    
        $headers = $this->protectedHeaders($headers);
        $options['headers'] = $headers;
        
        return $options;
    }
    
    
    /**
     * @return array
     */
    protected function protectedHeaders(array $headers = [])
    {
        if (empty($headers)) {
            $headers = $this->headers;
        }

        if (isset($headers[Api::AUTH_TOKEN])) {
            $headers[Api::AUTH_TOKEN] = $this->protectString($headers[Api::AUTH_TOKEN]);
        }
        
        return $headers;
    }
}
